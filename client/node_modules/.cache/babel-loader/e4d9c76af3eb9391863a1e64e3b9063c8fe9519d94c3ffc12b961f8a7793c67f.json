{"ast":null,"code":"var f = require('./formatters');\nvar SolidityParam = require('./param');\n\n/**\n * SolidityType prototype is used to encode/decode solidity params of certain type\n */\nvar SolidityType = function (config) {\n  this._inputFormatter = config.inputFormatter;\n  this._outputFormatter = config.outputFormatter;\n};\n\n/**\n * Should be used to determine if this SolidityType do match given name\n *\n * @method isType\n * @param {String} name\n * @return {Bool} true if type match this SolidityType, otherwise false\n */\nSolidityType.prototype.isType = function (name) {\n  throw \"this method should be overrwritten for type \" + name;\n};\n\n/**\n * Should be used to determine what is the length of static part in given type\n *\n * @method staticPartLength\n * @param {String} name\n * @return {Number} length of static part in bytes\n */\nSolidityType.prototype.staticPartLength = function (name) {\n  // If name isn't an array then treat it like a single element array.\n  return (this.nestedTypes(name) || ['[1]']).map(function (type) {\n    // the length of the nested array\n    return parseInt(type.slice(1, -1), 10) || 1;\n  }).reduce(function (previous, current) {\n    return previous * current;\n    // all basic types are 32 bytes long\n  }, 32);\n};\n\n/**\n * Should be used to determine if type is dynamic array\n * eg:\n * \"type[]\" => true\n * \"type[4]\" => false\n *\n * @method isDynamicArray\n * @param {String} name\n * @return {Bool} true if the type is dynamic array\n */\nSolidityType.prototype.isDynamicArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should be used to determine if type is static array\n * eg:\n * \"type[]\" => false\n * \"type[4]\" => true\n *\n * @method isStaticArray\n * @param {String} name\n * @return {Bool} true if the type is static array\n */\nSolidityType.prototype.isStaticArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should return length of static array\n * eg.\n * \"int[32]\" => 32\n * \"int256[14]\" => 14\n * \"int[2][3]\" => 3\n * \"int\" => 1\n * \"int[1]\" => 1\n * \"int[]\" => 1\n *\n * @method staticArrayLength\n * @param {String} name\n * @return {Number} static array length\n */\nSolidityType.prototype.staticArrayLength = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  if (nestedTypes) {\n    return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\n  }\n  return 1;\n};\n\n/**\n * Should return nested type\n * eg.\n * \"int[32]\" => \"int\"\n * \"int256[14]\" => \"int256\"\n * \"int[2][3]\" => \"int[2]\"\n * \"int\" => \"int\"\n * \"int[]\" => \"int\"\n *\n * @method nestedName\n * @param {String} name\n * @return {String} nested name\n */\nSolidityType.prototype.nestedName = function (name) {\n  // remove last [] in name\n  var nestedTypes = this.nestedTypes(name);\n  if (!nestedTypes) {\n    return name;\n  }\n  return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\n};\n\n/**\n * Should return true if type has dynamic size by default\n * such types are \"string\", \"bytes\"\n *\n * @method isDynamicType\n * @param {String} name\n * @return {Bool} true if is dynamic, otherwise false\n */\nSolidityType.prototype.isDynamicType = function () {\n  return false;\n};\n\n/**\n * Should return array of nested types\n * eg.\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\n * \"int[] => [\"[]\"]\n * \"int\" => null\n *\n * @method nestedTypes\n * @param {String} name\n * @return {Array} array of nested types\n */\nSolidityType.prototype.nestedTypes = function (name) {\n  // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\n  return name.match(/(\\[[0-9]*\\])/g);\n};\n\n/**\n * Should be used to encode the value\n *\n * @method encode\n * @param {Object} value\n * @param {String} name\n * @return {String} encoded value\n */\nSolidityType.prototype.encode = function (value, name) {\n  var self = this;\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var length = value.length; // in int\n      var nestedName = self.nestedName(name);\n      var result = [];\n      result.push(f.formatInputInt(length).encode());\n      value.forEach(function (v) {\n        result.push(self.encode(v, nestedName));\n      });\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n      var nestedName = self.nestedName(name);\n      var result = [];\n      for (var i = 0; i < length; i++) {\n        result.push(self.encode(value[i], nestedName));\n      }\n      return result;\n    }();\n  }\n  return this._inputFormatter(value, name).encode();\n};\n\n/**\n * Should be used to decode value from bytes\n *\n * @method decode\n * @param {String} bytes\n * @param {Number} offset in bytes\n * @param {String} name type name\n * @returns {Object} decoded value\n */\nSolidityType.prototype.decode = function (bytes, offset, name) {\n  var self = this;\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n      var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\n      var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n      var arrayStart = offset; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n      return result;\n    }();\n  } else if (this.isDynamicType(name)) {\n    return function () {\n      var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n      var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64)); // in bytes\n      var roundedLength = Math.floor((length + 31) / 32); // in int\n      var param = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0);\n      return self._outputFormatter(param, name);\n    }();\n  }\n  var length = this.staticPartLength(name);\n  var param = new SolidityParam(bytes.substr(offset * 2, length * 2));\n  return this._outputFormatter(param, name);\n};\nmodule.exports = SolidityType;","map":{"version":3,"names":["f","require","SolidityParam","SolidityType","config","_inputFormatter","inputFormatter","_outputFormatter","outputFormatter","prototype","isType","name","staticPartLength","nestedTypes","map","type","parseInt","slice","reduce","previous","current","isDynamicArray","length","match","isStaticArray","staticArrayLength","nestedName","substr","isDynamicType","encode","value","self","result","push","formatInputInt","forEach","v","i","decode","bytes","offset","arrayOffset","arrayStart","nestedStaticPartLength","roundedNestedStaticPartLength","Math","floor","dynamicOffset","roundedLength","param","module","exports"],"sources":["E:/Career/University at Buffalo/Semester 2/CSE_Blockchain/Project/playground/research-papers-bid/node_modules/web3/lib/solidity/type.js"],"sourcesContent":["var f = require('./formatters');\nvar SolidityParam = require('./param');\n\n/**\n * SolidityType prototype is used to encode/decode solidity params of certain type\n */\nvar SolidityType = function (config) {\n    this._inputFormatter = config.inputFormatter;\n    this._outputFormatter = config.outputFormatter;\n};\n\n/**\n * Should be used to determine if this SolidityType do match given name\n *\n * @method isType\n * @param {String} name\n * @return {Bool} true if type match this SolidityType, otherwise false\n */\nSolidityType.prototype.isType = function (name) {\n    throw \"this method should be overrwritten for type \" + name;\n};\n\n/**\n * Should be used to determine what is the length of static part in given type\n *\n * @method staticPartLength\n * @param {String} name\n * @return {Number} length of static part in bytes\n */\nSolidityType.prototype.staticPartLength = function (name) {\n    // If name isn't an array then treat it like a single element array.\n    return (this.nestedTypes(name) || ['[1]'])\n        .map(function (type) {\n            // the length of the nested array\n            return parseInt(type.slice(1, -1), 10) || 1;\n        })\n        .reduce(function (previous, current) {\n            return previous * current;\n        // all basic types are 32 bytes long\n        }, 32);\n};\n\n/**\n * Should be used to determine if type is dynamic array\n * eg:\n * \"type[]\" => true\n * \"type[4]\" => false\n *\n * @method isDynamicArray\n * @param {String} name\n * @return {Bool} true if the type is dynamic array\n */\nSolidityType.prototype.isDynamicArray = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should be used to determine if type is static array\n * eg:\n * \"type[]\" => false\n * \"type[4]\" => true\n *\n * @method isStaticArray\n * @param {String} name\n * @return {Bool} true if the type is static array\n */\nSolidityType.prototype.isStaticArray = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n\n/**\n * Should return length of static array\n * eg.\n * \"int[32]\" => 32\n * \"int256[14]\" => 14\n * \"int[2][3]\" => 3\n * \"int\" => 1\n * \"int[1]\" => 1\n * \"int[]\" => 1\n *\n * @method staticArrayLength\n * @param {String} name\n * @return {Number} static array length\n */\nSolidityType.prototype.staticArrayLength = function (name) {\n    var nestedTypes = this.nestedTypes(name);\n    if (nestedTypes) {\n       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\n    }\n    return 1;\n};\n\n/**\n * Should return nested type\n * eg.\n * \"int[32]\" => \"int\"\n * \"int256[14]\" => \"int256\"\n * \"int[2][3]\" => \"int[2]\"\n * \"int\" => \"int\"\n * \"int[]\" => \"int\"\n *\n * @method nestedName\n * @param {String} name\n * @return {String} nested name\n */\nSolidityType.prototype.nestedName = function (name) {\n    // remove last [] in name\n    var nestedTypes = this.nestedTypes(name);\n    if (!nestedTypes) {\n        return name;\n    }\n\n    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\n};\n\n/**\n * Should return true if type has dynamic size by default\n * such types are \"string\", \"bytes\"\n *\n * @method isDynamicType\n * @param {String} name\n * @return {Bool} true if is dynamic, otherwise false\n */\nSolidityType.prototype.isDynamicType = function () {\n    return false;\n};\n\n/**\n * Should return array of nested types\n * eg.\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\n * \"int[] => [\"[]\"]\n * \"int\" => null\n *\n * @method nestedTypes\n * @param {String} name\n * @return {Array} array of nested types\n */\nSolidityType.prototype.nestedTypes = function (name) {\n    // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\n    return name.match(/(\\[[0-9]*\\])/g);\n};\n\n/**\n * Should be used to encode the value\n *\n * @method encode\n * @param {Object} value\n * @param {String} name\n * @return {String} encoded value\n */\nSolidityType.prototype.encode = function (value, name) {\n    var self = this;\n    if (this.isDynamicArray(name)) {\n\n        return (function () {\n            var length = value.length;                          // in int\n            var nestedName = self.nestedName(name);\n\n            var result = [];\n            result.push(f.formatInputInt(length).encode());\n\n            value.forEach(function (v) {\n                result.push(self.encode(v, nestedName));\n            });\n\n            return result;\n        })();\n\n    } else if (this.isStaticArray(name)) {\n\n        return (function () {\n            var length = self.staticArrayLength(name);          // in int\n            var nestedName = self.nestedName(name);\n\n            var result = [];\n            for (var i = 0; i < length; i++) {\n                result.push(self.encode(value[i], nestedName));\n            }\n\n            return result;\n        })();\n\n    }\n\n    return this._inputFormatter(value, name).encode();\n};\n\n/**\n * Should be used to decode value from bytes\n *\n * @method decode\n * @param {String} bytes\n * @param {Number} offset in bytes\n * @param {String} name type name\n * @returns {Object} decoded value\n */\nSolidityType.prototype.decode = function (bytes, offset, name) {\n    var self = this;\n\n    if (this.isDynamicArray(name)) {\n\n        return (function () {\n            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\n            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\n\n            var nestedName = self.nestedName(name);\n            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n            var result = [];\n\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\n            }\n\n            return result;\n        })();\n\n    } else if (this.isStaticArray(name)) {\n\n        return (function () {\n            var length = self.staticArrayLength(name);                      // in int\n            var arrayStart = offset;                                        // in bytes\n\n            var nestedName = self.nestedName(name);\n            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n            var result = [];\n\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\n            }\n\n            return result;\n        })();\n    } else if (this.isDynamicType(name)) {\n\n        return (function () {\n            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes\n            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes\n            var roundedLength = Math.floor((length + 31) / 32);                     // in int\n            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);\n            return self._outputFormatter(param, name);\n        })();\n    }\n\n    var length = this.staticPartLength(name);\n    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));\n    return this._outputFormatter(param, name);\n};\n\nmodule.exports = SolidityType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}