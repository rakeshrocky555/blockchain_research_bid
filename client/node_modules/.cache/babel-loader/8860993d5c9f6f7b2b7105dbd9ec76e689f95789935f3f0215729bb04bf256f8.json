{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file contract.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2014\n */\n\nvar utils = require('../utils/utils');\nvar coder = require('../solidity/coder');\nvar SolidityEvent = require('./event');\nvar SolidityFunction = require('./function');\nvar AllEvents = require('./allevents');\n\n/**\n * Should be called to encode constructor params\n *\n * @method encodeConstructorParams\n * @param {Array} abi\n * @param {Array} constructor params\n */\nvar encodeConstructorParams = function (abi, params) {\n  return abi.filter(function (json) {\n    return json.type === 'constructor' && json.inputs.length === params.length;\n  }).map(function (json) {\n    return json.inputs.map(function (input) {\n      return input.type;\n    });\n  }).map(function (types) {\n    return coder.encodeParams(types, params);\n  })[0] || '';\n};\n\n/**\n * Should be called to add functions to contract object\n *\n * @method addFunctionsToContract\n * @param {Contract} contract\n * @param {Array} abi\n */\nvar addFunctionsToContract = function (contract) {\n  contract.abi.filter(function (json) {\n    return json.type === 'function';\n  }).map(function (json) {\n    return new SolidityFunction(contract._eth, json, contract.address);\n  }).forEach(function (f) {\n    f.attachToContract(contract);\n  });\n};\n\n/**\n * Should be called to add events to contract object\n *\n * @method addEventsToContract\n * @param {Contract} contract\n * @param {Array} abi\n */\nvar addEventsToContract = function (contract) {\n  var events = contract.abi.filter(function (json) {\n    return json.type === 'event';\n  });\n  var All = new AllEvents(contract._eth._requestManager, events, contract.address);\n  All.attachToContract(contract);\n  events.map(function (json) {\n    return new SolidityEvent(contract._eth._requestManager, json, contract.address);\n  }).forEach(function (e) {\n    e.attachToContract(contract);\n  });\n};\n\n/**\n * Should be called to check if the contract gets properly deployed on the blockchain.\n *\n * @method checkForContractAddress\n * @param {Object} contract\n * @param {Function} callback\n * @returns {Undefined}\n */\nvar checkForContractAddress = function (contract, callback) {\n  var count = 0,\n    callbackFired = false;\n\n  // wait for receipt\n  var filter = contract._eth.filter('latest', function (e) {\n    if (!e && !callbackFired) {\n      count++;\n\n      // stop watching after 50 blocks (timeout)\n      if (count > 50) {\n        filter.stopWatching(function () {});\n        callbackFired = true;\n        if (callback) callback(new Error('Contract transaction couldn\\'t be found after 50 blocks'));else throw new Error('Contract transaction couldn\\'t be found after 50 blocks');\n      } else {\n        contract._eth.getTransactionReceipt(contract.transactionHash, function (e, receipt) {\n          if (receipt && receipt.blockHash && !callbackFired) {\n            contract._eth.getCode(receipt.contractAddress, function (e, code) {\n              /*jshint maxcomplexity: 6 */\n\n              if (callbackFired || !code) return;\n              filter.stopWatching(function () {});\n              callbackFired = true;\n              if (code.length > 3) {\n                // console.log('Contract code deployed!');\n\n                contract.address = receipt.contractAddress;\n\n                // attach events and methods again after we have\n                addFunctionsToContract(contract);\n                addEventsToContract(contract);\n\n                // call callback for the second time\n                if (callback) callback(null, contract);\n              } else {\n                if (callback) callback(new Error('The contract code couldn\\'t be stored, please check your gas amount.'));else throw new Error('The contract code couldn\\'t be stored, please check your gas amount.');\n              }\n            });\n          }\n        });\n      }\n    }\n  });\n};\n\n/**\n * Should be called to create new ContractFactory instance\n *\n * @method ContractFactory\n * @param {Array} abi\n */\nvar ContractFactory = function (eth, abi) {\n  this.eth = eth;\n  this.abi = abi;\n\n  /**\n   * Should be called to create new contract on a blockchain\n   *\n   * @method new\n   * @param {Any} contract constructor param1 (optional)\n   * @param {Any} contract constructor param2 (optional)\n   * @param {Object} contract transaction object (required)\n   * @param {Function} callback\n   * @returns {Contract} returns contract instance\n   */\n  this.new = function () {\n    /*jshint maxcomplexity: 7 */\n\n    var contract = new Contract(this.eth, this.abi);\n\n    // parse arguments\n    var options = {}; // required!\n    var callback;\n    var args = Array.prototype.slice.call(arguments);\n    if (utils.isFunction(args[args.length - 1])) {\n      callback = args.pop();\n    }\n    var last = args[args.length - 1];\n    if (utils.isObject(last) && !utils.isArray(last)) {\n      options = args.pop();\n    }\n    if (options.value > 0) {\n      var constructorAbi = abi.filter(function (json) {\n        return json.type === 'constructor' && json.inputs.length === args.length;\n      })[0] || {};\n      if (!constructorAbi.payable) {\n        throw new Error('Cannot send value to non-payable constructor');\n      }\n    }\n    var bytes = encodeConstructorParams(this.abi, args);\n    options.data += bytes;\n    if (callback) {\n      // wait for the contract address and check if the code was deployed\n      this.eth.sendTransaction(options, function (err, hash) {\n        if (err) {\n          callback(err);\n        } else {\n          // add the transaction hash\n          contract.transactionHash = hash;\n\n          // call callback for the first time\n          callback(null, contract);\n          checkForContractAddress(contract, callback);\n        }\n      });\n    } else {\n      var hash = this.eth.sendTransaction(options);\n      // add the transaction hash\n      contract.transactionHash = hash;\n      checkForContractAddress(contract);\n    }\n    return contract;\n  };\n  this.new.getData = this.getData.bind(this);\n};\n\n/**\n * Should be called to create new ContractFactory\n *\n * @method contract\n * @param {Array} abi\n * @returns {ContractFactory} new contract factory\n */\n//var contract = function (abi) {\n//return new ContractFactory(abi);\n//};\n\n/**\n * Should be called to get access to existing contract on a blockchain\n *\n * @method at\n * @param {Address} contract address (required)\n * @param {Function} callback {optional)\n * @returns {Contract} returns contract if no callback was passed,\n * otherwise calls callback function (err, contract)\n */\nContractFactory.prototype.at = function (address, callback) {\n  var contract = new Contract(this.eth, this.abi, address);\n\n  // this functions are not part of prototype,\n  // because we dont want to spoil the interface\n  addFunctionsToContract(contract);\n  addEventsToContract(contract);\n  if (callback) {\n    callback(null, contract);\n  }\n  return contract;\n};\n\n/**\n * Gets the data, which is data to deploy plus constructor params\n *\n * @method getData\n */\nContractFactory.prototype.getData = function () {\n  var options = {}; // required!\n  var args = Array.prototype.slice.call(arguments);\n  var last = args[args.length - 1];\n  if (utils.isObject(last) && !utils.isArray(last)) {\n    options = args.pop();\n  }\n  var bytes = encodeConstructorParams(this.abi, args);\n  options.data += bytes;\n  return options.data;\n};\n\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @param {Array} abi\n * @param {Address} contract address\n */\nvar Contract = function (eth, abi, address) {\n  this._eth = eth;\n  this.transactionHash = null;\n  this.address = address;\n  this.abi = abi;\n};\nmodule.exports = ContractFactory;","map":{"version":3,"names":["utils","require","coder","SolidityEvent","SolidityFunction","AllEvents","encodeConstructorParams","abi","params","filter","json","type","inputs","length","map","input","types","encodeParams","addFunctionsToContract","contract","_eth","address","forEach","f","attachToContract","addEventsToContract","events","All","_requestManager","e","checkForContractAddress","callback","count","callbackFired","stopWatching","Error","getTransactionReceipt","transactionHash","receipt","blockHash","getCode","contractAddress","code","ContractFactory","eth","new","Contract","options","args","Array","prototype","slice","call","arguments","isFunction","pop","last","isObject","isArray","value","constructorAbi","payable","bytes","data","sendTransaction","err","hash","getData","bind","at","module","exports"],"sources":["E:/Career/University at Buffalo/Semester 2/CSE_Blockchain/Project/playground/research-papers-bid/node_modules/web3/lib/web3/contract.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file contract.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2014\n */\n\nvar utils = require('../utils/utils');\nvar coder = require('../solidity/coder');\nvar SolidityEvent = require('./event');\nvar SolidityFunction = require('./function');\nvar AllEvents = require('./allevents');\n\n/**\n * Should be called to encode constructor params\n *\n * @method encodeConstructorParams\n * @param {Array} abi\n * @param {Array} constructor params\n */\nvar encodeConstructorParams = function (abi, params) {\n    return abi.filter(function (json) {\n        return json.type === 'constructor' && json.inputs.length === params.length;\n    }).map(function (json) {\n        return json.inputs.map(function (input) {\n            return input.type;\n        });\n    }).map(function (types) {\n        return coder.encodeParams(types, params);\n    })[0] || '';\n};\n\n/**\n * Should be called to add functions to contract object\n *\n * @method addFunctionsToContract\n * @param {Contract} contract\n * @param {Array} abi\n */\nvar addFunctionsToContract = function (contract) {\n    contract.abi.filter(function (json) {\n        return json.type === 'function';\n    }).map(function (json) {\n        return new SolidityFunction(contract._eth, json, contract.address);\n    }).forEach(function (f) {\n        f.attachToContract(contract);\n    });\n};\n\n/**\n * Should be called to add events to contract object\n *\n * @method addEventsToContract\n * @param {Contract} contract\n * @param {Array} abi\n */\nvar addEventsToContract = function (contract) {\n    var events = contract.abi.filter(function (json) {\n        return json.type === 'event';\n    });\n\n    var All = new AllEvents(contract._eth._requestManager, events, contract.address);\n    All.attachToContract(contract);\n\n    events.map(function (json) {\n        return new SolidityEvent(contract._eth._requestManager, json, contract.address);\n    }).forEach(function (e) {\n        e.attachToContract(contract);\n    });\n};\n\n\n/**\n * Should be called to check if the contract gets properly deployed on the blockchain.\n *\n * @method checkForContractAddress\n * @param {Object} contract\n * @param {Function} callback\n * @returns {Undefined}\n */\nvar checkForContractAddress = function(contract, callback){\n    var count = 0,\n        callbackFired = false;\n\n    // wait for receipt\n    var filter = contract._eth.filter('latest', function(e){\n        if (!e && !callbackFired) {\n            count++;\n\n            // stop watching after 50 blocks (timeout)\n            if (count > 50) {\n\n                filter.stopWatching(function() {});\n                callbackFired = true;\n\n                if (callback)\n                    callback(new Error('Contract transaction couldn\\'t be found after 50 blocks'));\n                else\n                    throw new Error('Contract transaction couldn\\'t be found after 50 blocks');\n\n\n            } else {\n\n                contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt){\n                    if(receipt && receipt.blockHash && !callbackFired) {\n\n                        contract._eth.getCode(receipt.contractAddress, function(e, code){\n                            /*jshint maxcomplexity: 6 */\n\n                            if(callbackFired || !code)\n                                return;\n\n                            filter.stopWatching(function() {});\n                            callbackFired = true;\n\n                            if(code.length > 3) {\n\n                                // console.log('Contract code deployed!');\n\n                                contract.address = receipt.contractAddress;\n\n                                // attach events and methods again after we have\n                                addFunctionsToContract(contract);\n                                addEventsToContract(contract);\n\n                                // call callback for the second time\n                                if(callback)\n                                    callback(null, contract);\n\n                            } else {\n                                if(callback)\n                                    callback(new Error('The contract code couldn\\'t be stored, please check your gas amount.'));\n                                else\n                                    throw new Error('The contract code couldn\\'t be stored, please check your gas amount.');\n                            }\n                        });\n                    }\n                });\n            }\n        }\n    });\n};\n\n/**\n * Should be called to create new ContractFactory instance\n *\n * @method ContractFactory\n * @param {Array} abi\n */\nvar ContractFactory = function (eth, abi) {\n    this.eth = eth;\n    this.abi = abi;\n\n    /**\n     * Should be called to create new contract on a blockchain\n     *\n     * @method new\n     * @param {Any} contract constructor param1 (optional)\n     * @param {Any} contract constructor param2 (optional)\n     * @param {Object} contract transaction object (required)\n     * @param {Function} callback\n     * @returns {Contract} returns contract instance\n     */\n    this.new = function () {\n        /*jshint maxcomplexity: 7 */\n\n        var contract = new Contract(this.eth, this.abi);\n\n        // parse arguments\n        var options = {}; // required!\n        var callback;\n\n        var args = Array.prototype.slice.call(arguments);\n        if (utils.isFunction(args[args.length - 1])) {\n            callback = args.pop();\n        }\n\n        var last = args[args.length - 1];\n        if (utils.isObject(last) && !utils.isArray(last)) {\n            options = args.pop();\n        }\n\n        if (options.value > 0) {\n            var constructorAbi = abi.filter(function (json) {\n                return json.type === 'constructor' && json.inputs.length === args.length;\n            })[0] || {};\n\n            if (!constructorAbi.payable) {\n                throw new Error('Cannot send value to non-payable constructor');\n            }\n        }\n\n        var bytes = encodeConstructorParams(this.abi, args);\n        options.data += bytes;\n\n        if (callback) {\n\n            // wait for the contract address and check if the code was deployed\n            this.eth.sendTransaction(options, function (err, hash) {\n                if (err) {\n                    callback(err);\n                } else {\n                    // add the transaction hash\n                    contract.transactionHash = hash;\n\n                    // call callback for the first time\n                    callback(null, contract);\n\n                    checkForContractAddress(contract, callback);\n                }\n            });\n        } else {\n            var hash = this.eth.sendTransaction(options);\n            // add the transaction hash\n            contract.transactionHash = hash;\n            checkForContractAddress(contract);\n        }\n\n        return contract;\n    };\n\n    this.new.getData = this.getData.bind(this);\n};\n\n/**\n * Should be called to create new ContractFactory\n *\n * @method contract\n * @param {Array} abi\n * @returns {ContractFactory} new contract factory\n */\n//var contract = function (abi) {\n    //return new ContractFactory(abi);\n//};\n\n\n\n/**\n * Should be called to get access to existing contract on a blockchain\n *\n * @method at\n * @param {Address} contract address (required)\n * @param {Function} callback {optional)\n * @returns {Contract} returns contract if no callback was passed,\n * otherwise calls callback function (err, contract)\n */\nContractFactory.prototype.at = function (address, callback) {\n    var contract = new Contract(this.eth, this.abi, address);\n\n    // this functions are not part of prototype,\n    // because we dont want to spoil the interface\n    addFunctionsToContract(contract);\n    addEventsToContract(contract);\n\n    if (callback) {\n        callback(null, contract);\n    }\n    return contract;\n};\n\n/**\n * Gets the data, which is data to deploy plus constructor params\n *\n * @method getData\n */\nContractFactory.prototype.getData = function () {\n    var options = {}; // required!\n    var args = Array.prototype.slice.call(arguments);\n\n    var last = args[args.length - 1];\n    if (utils.isObject(last) && !utils.isArray(last)) {\n        options = args.pop();\n    }\n\n    var bytes = encodeConstructorParams(this.abi, args);\n    options.data += bytes;\n\n    return options.data;\n};\n\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @param {Array} abi\n * @param {Address} contract address\n */\nvar Contract = function (eth, abi, address) {\n    this._eth = eth;\n    this.transactionHash = null;\n    this.address = address;\n    this.abi = abi;\n};\n\nmodule.exports = ContractFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}