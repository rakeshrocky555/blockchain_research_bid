{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\n\nvar BigNumber = require('bignumber.js');\nvar utils = require('../utils/utils');\nvar c = require('../utils/config');\nvar SolidityParam = require('./param');\n\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BigNumber} value that needs to be formatted\n * @returns {SolidityParam}\n */\nvar formatInputInt = function (value) {\n  BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);\n  var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);\n  return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputBytes = function (value) {\n  var result = utils.toHex(value).substr(2);\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputDynamicBytes = function (value) {\n  var result = utils.toHex(value).substr(2);\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputString = function (value) {\n  var result = utils.fromUtf8(value).substr(2);\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\nvar formatInputBool = function (value) {\n  var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ? '1' : '0');\n  return new SolidityParam(result);\n};\n\n/**\n * Formats input value to byte representation of real\n * Values are multiplied by 2^m and encoded as integers\n *\n * @method formatInputReal\n * @param {String|Number|BigNumber}\n * @returns {SolidityParam}\n */\nvar formatInputReal = function (value) {\n  return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));\n};\n\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\nvar signedIsNegative = function (value) {\n  return new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1) === '1';\n};\n\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BigNumber} right-aligned output bytes formatted to big number\n */\nvar formatOutputInt = function (param) {\n  var value = param.staticPart() || \"0\";\n\n  // check if it's negative number\n  // it it is, return two's complement\n  if (signedIsNegative(value)) {\n    return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);\n  }\n  return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam}\n * @returns {BigNumeber} right-aligned output bytes formatted to uint\n */\nvar formatOutputUInt = function (param) {\n  var value = param.staticPart() || \"0\";\n  return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to real\n *\n * @method formatOutputReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to real\n */\nvar formatOutputReal = function (param) {\n  return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Formats right-aligned output bytes to ureal\n *\n * @method formatOutputUReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to ureal\n */\nvar formatOutputUReal = function (param) {\n  return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam}\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\nvar formatOutputBool = function (param) {\n  return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\nvar formatOutputBytes = function (param, name) {\n  var matches = name.match(/^bytes([0-9]*)/);\n  var size = parseInt(matches[1]);\n  return '0x' + param.staticPart().slice(0, 2 * size);\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} hex string\n */\nvar formatOutputDynamicBytes = function (param) {\n  var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;\n  return '0x' + param.dynamicPart().substr(64, length);\n};\n\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\nvar formatOutputString = function (param) {\n  var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;\n  return utils.toUtf8(param.dynamicPart().substr(64, length));\n};\n\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} right-aligned input bytes\n * @returns {String} address\n */\nvar formatOutputAddress = function (param) {\n  var value = param.staticPart();\n  return \"0x\" + value.slice(value.length - 40, value.length);\n};\nmodule.exports = {\n  formatInputInt: formatInputInt,\n  formatInputBytes: formatInputBytes,\n  formatInputDynamicBytes: formatInputDynamicBytes,\n  formatInputString: formatInputString,\n  formatInputBool: formatInputBool,\n  formatInputReal: formatInputReal,\n  formatOutputInt: formatOutputInt,\n  formatOutputUInt: formatOutputUInt,\n  formatOutputReal: formatOutputReal,\n  formatOutputUReal: formatOutputUReal,\n  formatOutputBool: formatOutputBool,\n  formatOutputBytes: formatOutputBytes,\n  formatOutputDynamicBytes: formatOutputDynamicBytes,\n  formatOutputString: formatOutputString,\n  formatOutputAddress: formatOutputAddress\n};","map":{"version":3,"names":["BigNumber","require","utils","c","SolidityParam","formatInputInt","value","config","ETH_BIGNUMBER_ROUNDING_MODE","result","padLeft","toTwosComplement","toString","formatInputBytes","toHex","substr","l","Math","floor","length","padRight","formatInputDynamicBytes","formatInputString","fromUtf8","formatInputBool","formatInputReal","times","pow","signedIsNegative","formatOutputInt","param","staticPart","minus","formatOutputUInt","formatOutputReal","dividedBy","formatOutputUReal","formatOutputBool","formatOutputBytes","name","matches","match","size","parseInt","slice","formatOutputDynamicBytes","dynamicPart","toNumber","formatOutputString","toUtf8","formatOutputAddress","module","exports"],"sources":["E:/Career/University at Buffalo/Semester 2/CSE_Blockchain/Project/playground/research-papers-bid/node_modules/web3/lib/solidity/formatters.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\n\nvar BigNumber = require('bignumber.js');\nvar utils = require('../utils/utils');\nvar c = require('../utils/config');\nvar SolidityParam = require('./param');\n\n\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BigNumber} value that needs to be formatted\n * @returns {SolidityParam}\n */\nvar formatInputInt = function (value) {\n    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);\n    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputBytes = function (value) {\n    var result = utils.toHex(value).substr(2);\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputDynamicBytes = function (value) {\n    var result = utils.toHex(value).substr(2);\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputString = function (value) {\n    var result = utils.fromUtf8(value).substr(2);\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\nvar formatInputBool = function (value) {\n    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input value to byte representation of real\n * Values are multiplied by 2^m and encoded as integers\n *\n * @method formatInputReal\n * @param {String|Number|BigNumber}\n * @returns {SolidityParam}\n */\nvar formatInputReal = function (value) {\n    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));\n};\n\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\nvar signedIsNegative = function (value) {\n    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\n};\n\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BigNumber} right-aligned output bytes formatted to big number\n */\nvar formatOutputInt = function (param) {\n    var value = param.staticPart() || \"0\";\n\n    // check if it's negative number\n    // it it is, return two's complement\n    if (signedIsNegative(value)) {\n        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);\n    }\n    return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam}\n * @returns {BigNumeber} right-aligned output bytes formatted to uint\n */\nvar formatOutputUInt = function (param) {\n    var value = param.staticPart() || \"0\";\n    return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to real\n *\n * @method formatOutputReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to real\n */\nvar formatOutputReal = function (param) {\n    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Formats right-aligned output bytes to ureal\n *\n * @method formatOutputUReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to ureal\n */\nvar formatOutputUReal = function (param) {\n    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam}\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\nvar formatOutputBool = function (param) {\n    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\nvar formatOutputBytes = function (param, name) {\n    var matches = name.match(/^bytes([0-9]*)/);\n    var size = parseInt(matches[1]);\n    return '0x' + param.staticPart().slice(0, 2 * size);\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} hex string\n */\nvar formatOutputDynamicBytes = function (param) {\n    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;\n    return '0x' + param.dynamicPart().substr(64, length);\n};\n\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\nvar formatOutputString = function (param) {\n    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;\n    return utils.toUtf8(param.dynamicPart().substr(64, length));\n};\n\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} right-aligned input bytes\n * @returns {String} address\n */\nvar formatOutputAddress = function (param) {\n    var value = param.staticPart();\n    return \"0x\" + value.slice(value.length - 40, value.length);\n};\n\nmodule.exports = {\n    formatInputInt: formatInputInt,\n    formatInputBytes: formatInputBytes,\n    formatInputDynamicBytes: formatInputDynamicBytes,\n    formatInputString: formatInputString,\n    formatInputBool: formatInputBool,\n    formatInputReal: formatInputReal,\n    formatOutputInt: formatOutputInt,\n    formatOutputUInt: formatOutputUInt,\n    formatOutputReal: formatOutputReal,\n    formatOutputUReal: formatOutputUReal,\n    formatOutputBool: formatOutputBool,\n    formatOutputBytes: formatOutputBytes,\n    formatOutputDynamicBytes: formatOutputDynamicBytes,\n    formatOutputString: formatOutputString,\n    formatOutputAddress: formatOutputAddress\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}