{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file ipcprovider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethdev.com>\n * @date 2015\n */\n\n\"use strict\";\n\nvar utils = require('../utils/utils');\nvar errors = require('./errors');\nvar IpcProvider = function (path, net) {\n  var _this = this;\n  this.responseCallbacks = {};\n  this.path = path;\n  this.connection = net.connect({\n    path: this.path\n  });\n  this.connection.on('error', function (e) {\n    console.error('IPC Connection Error', e);\n    _this._timeout();\n  });\n  this.connection.on('end', function () {\n    _this._timeout();\n  });\n\n  // LISTEN FOR CONNECTION RESPONSES\n  this.connection.on('data', function (data) {\n    /*jshint maxcomplexity: 6 */\n\n    _this._parseResponse(data.toString()).forEach(function (result) {\n      var id = null;\n\n      // get the id which matches the returned id\n      if (utils.isArray(result)) {\n        result.forEach(function (load) {\n          if (_this.responseCallbacks[load.id]) id = load.id;\n        });\n      } else {\n        id = result.id;\n      }\n\n      // fire the callback\n      if (_this.responseCallbacks[id]) {\n        _this.responseCallbacks[id](null, result);\n        delete _this.responseCallbacks[id];\n      }\n    });\n  });\n};\n\n/**\nWill parse the response and make an array out of it.\n\n@method _parseResponse\n@param {String} data\n*/\nIpcProvider.prototype._parseResponse = function (data) {\n  var _this = this,\n    returnValues = [];\n\n  // DE-CHUNKER\n  var dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n  .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n  .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n  .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n  .split('|--|');\n  dechunkedData.forEach(function (data) {\n    // prepend the last chunk\n    if (_this.lastChunk) data = _this.lastChunk + data;\n    var result = null;\n    try {\n      result = JSON.parse(data);\n    } catch (e) {\n      _this.lastChunk = data;\n\n      // start timeout to cancel all requests\n      clearTimeout(_this.lastChunkTimeout);\n      _this.lastChunkTimeout = setTimeout(function () {\n        _this._timeout();\n        throw errors.InvalidResponse(data);\n      }, 1000 * 15);\n      return;\n    }\n\n    // cancel timeout and set chunk to null\n    clearTimeout(_this.lastChunkTimeout);\n    _this.lastChunk = null;\n    if (result) returnValues.push(result);\n  });\n  return returnValues;\n};\n\n/**\nGet the adds a callback to the responseCallbacks object,\nwhich will be called if a response matching the response Id will arrive.\n\n@method _addResponseCallback\n*/\nIpcProvider.prototype._addResponseCallback = function (payload, callback) {\n  var id = payload.id || payload[0].id;\n  var method = payload.method || payload[0].method;\n  this.responseCallbacks[id] = callback;\n  this.responseCallbacks[id].method = method;\n};\n\n/**\nTimeout all requests when the end/error event is fired\n\n@method _timeout\n*/\nIpcProvider.prototype._timeout = function () {\n  for (var key in this.responseCallbacks) {\n    if (this.responseCallbacks.hasOwnProperty(key)) {\n      this.responseCallbacks[key](errors.InvalidConnection('on IPC'));\n      delete this.responseCallbacks[key];\n    }\n  }\n};\n\n/**\nCheck if the current connection is still valid.\n\n@method isConnected\n*/\nIpcProvider.prototype.isConnected = function () {\n  var _this = this;\n\n  // try reconnect, when connection is gone\n  if (!_this.connection.writable) _this.connection.connect({\n    path: _this.path\n  });\n  return !!this.connection.writable;\n};\nIpcProvider.prototype.send = function (payload) {\n  if (this.connection.writeSync) {\n    var result;\n\n    // try reconnect, when connection is gone\n    if (!this.connection.writable) this.connection.connect({\n      path: this.path\n    });\n    var data = this.connection.writeSync(JSON.stringify(payload));\n    try {\n      result = JSON.parse(data);\n    } catch (e) {\n      throw errors.InvalidResponse(data);\n    }\n    return result;\n  } else {\n    throw new Error('You tried to send \"' + payload.method + '\" synchronously. Synchronous requests are not supported by the IPC provider.');\n  }\n};\nIpcProvider.prototype.sendAsync = function (payload, callback) {\n  // try reconnect, when connection is gone\n  if (!this.connection.writable) this.connection.connect({\n    path: this.path\n  });\n  this.connection.write(JSON.stringify(payload));\n  this._addResponseCallback(payload, callback);\n};\nmodule.exports = IpcProvider;","map":{"version":3,"names":["utils","require","errors","IpcProvider","path","net","_this","responseCallbacks","connection","connect","on","e","console","error","_timeout","data","_parseResponse","toString","forEach","result","id","isArray","load","prototype","returnValues","dechunkedData","replace","split","lastChunk","JSON","parse","clearTimeout","lastChunkTimeout","setTimeout","InvalidResponse","push","_addResponseCallback","payload","callback","method","key","hasOwnProperty","InvalidConnection","isConnected","writable","send","writeSync","stringify","Error","sendAsync","write","module","exports"],"sources":["E:/Career/University at Buffalo/Semester 2/CSE_Blockchain/Project/playground/research-papers-bid/node_modules/web3/lib/web3/ipcprovider.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file ipcprovider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethdev.com>\n * @date 2015\n */\n\n\"use strict\";\n\nvar utils = require('../utils/utils');\nvar errors = require('./errors');\n\n\nvar IpcProvider = function (path, net) {\n    var _this = this;\n    this.responseCallbacks = {};\n    this.path = path;\n    \n    this.connection = net.connect({path: this.path});\n\n    this.connection.on('error', function(e){\n        console.error('IPC Connection Error', e);\n        _this._timeout();\n    });\n\n    this.connection.on('end', function(){\n        _this._timeout();\n    }); \n\n\n    // LISTEN FOR CONNECTION RESPONSES\n    this.connection.on('data', function(data) {\n        /*jshint maxcomplexity: 6 */\n\n        _this._parseResponse(data.toString()).forEach(function(result){\n\n            var id = null;\n\n            // get the id which matches the returned id\n            if(utils.isArray(result)) {\n                result.forEach(function(load){\n                    if(_this.responseCallbacks[load.id])\n                        id = load.id;\n                });\n            } else {\n                id = result.id;\n            }\n\n            // fire the callback\n            if(_this.responseCallbacks[id]) {\n                _this.responseCallbacks[id](null, result);\n                delete _this.responseCallbacks[id];\n            }\n        });\n    });\n};\n\n/**\nWill parse the response and make an array out of it.\n\n@method _parseResponse\n@param {String} data\n*/\nIpcProvider.prototype._parseResponse = function(data) {\n    var _this = this,\n        returnValues = [];\n    \n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g,'}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g,'}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g,'}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g,'}]|--|{') // }]{\n        .split('|--|');\n\n    dechunkedData.forEach(function(data){\n\n        // prepend the last chunk\n        if(_this.lastChunk)\n            data = _this.lastChunk + data;\n\n        var result = null;\n\n        try {\n            result = JSON.parse(data);\n\n        } catch(e) {\n\n            _this.lastChunk = data;\n\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function(){\n                _this._timeout();\n                throw errors.InvalidResponse(data);\n            }, 1000 * 15);\n\n            return;\n        }\n\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n\n        if(result)\n            returnValues.push(result);\n    });\n\n    return returnValues;\n};\n\n\n/**\nGet the adds a callback to the responseCallbacks object,\nwhich will be called if a response matching the response Id will arrive.\n\n@method _addResponseCallback\n*/\nIpcProvider.prototype._addResponseCallback = function(payload, callback) {\n    var id = payload.id || payload[0].id;\n    var method = payload.method || payload[0].method;\n\n    this.responseCallbacks[id] = callback;\n    this.responseCallbacks[id].method = method;\n};\n\n/**\nTimeout all requests when the end/error event is fired\n\n@method _timeout\n*/\nIpcProvider.prototype._timeout = function() {\n    for(var key in this.responseCallbacks) {\n        if(this.responseCallbacks.hasOwnProperty(key)){\n            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));\n            delete this.responseCallbacks[key];\n        }\n    }\n};\n\n\n/**\nCheck if the current connection is still valid.\n\n@method isConnected\n*/\nIpcProvider.prototype.isConnected = function() {\n    var _this = this;\n\n    // try reconnect, when connection is gone\n    if(!_this.connection.writable)\n        _this.connection.connect({path: _this.path});\n\n    return !!this.connection.writable;\n};\n\nIpcProvider.prototype.send = function (payload) {\n\n    if(this.connection.writeSync) {\n        var result;\n\n        // try reconnect, when connection is gone\n        if(!this.connection.writable)\n            this.connection.connect({path: this.path});\n\n        var data = this.connection.writeSync(JSON.stringify(payload));\n\n        try {\n            result = JSON.parse(data);\n        } catch(e) {\n            throw errors.InvalidResponse(data);                \n        }\n\n        return result;\n\n    } else {\n        throw new Error('You tried to send \"'+ payload.method +'\" synchronously. Synchronous requests are not supported by the IPC provider.');\n    }\n};\n\nIpcProvider.prototype.sendAsync = function (payload, callback) {\n    // try reconnect, when connection is gone\n    if(!this.connection.writable)\n        this.connection.connect({path: this.path});\n\n\n    this.connection.write(JSON.stringify(payload));\n    this._addResponseCallback(payload, callback);\n};\n\nmodule.exports = IpcProvider;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}